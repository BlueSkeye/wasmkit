6.1 Conventions
The textual format for WebAssembly modules is a rendering of their abstract syntax into S-expressions34.
Like the binary format, the text format is defined by an attribute grammar. A text string is a well-formed description
of a module if and only if it is generated by the grammar. Each production of this grammar has at most
one synthesized attribute: the abstract syntax that the respective character sequence expresses. Thus, the attribute
grammar implicitly defines a parsing function. Some productions also take a context as an inherited attribute that
records bound identifers.
Except for a few exceptions, the core of the text grammar closely mirrors the grammar of the abstract syntax.
However, it also defines a number of abbreviations that are “syntactic sugar” over the core syntax.
The recommended extension for source files containing WebAssembly modules in text format is “.wat”. Files
with this extension are assumed to be encoded in UTF-8, as per Unicode35 (Section 2.5).
6.1.1 Grammar
The following conventions are adopted in defining grammar rules for the text format. They mirror the conventions
used for abstract syntax and for the binary format. In order to distinguish symbols of the textual syntax from
symbols of the abstract syntax, typewriter font is adopted for the former.
• Terminal symbols are either literal strings of characters enclosed in quotes: ‘module’; or expressed as
Unicode36 code points: U+0A. (All characters written literally are unambiguously drawn from the 7-bit
ASCII37 subset of Unicode.)
• Nonterminal symbols are written in typewriter font: valtype, instr.
• 𝑇𝑛 is a sequence of 𝑛 ≥ 0 iterations of 𝑇.
• 𝑇* is a possibly empty sequence of iterations of 𝑇. (This is a shorthand for 𝑇𝑛 used where 𝑛 is not relevant.)
• 𝑇+ is a sequence of one or more iterations of 𝑇. (This is a shorthand for 𝑇𝑛 where 𝑛 ≥ 1.)
• 𝑇? is an optional occurrence of 𝑇. (This is a shorthand for 𝑇𝑛 where 𝑛 ≤ 1.)
34 https://en.wikipedia.org/wiki/S-expression
35 http://www.unicode.org/versions/latest/
36 http://www.unicode.org/versions/latest/
37 http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d

• 𝑥:𝑇 denotes the same language as the nonterminal 𝑇, but also binds the variable 𝑥 to the attribute synthesized for 𝑇.
• Productions are written sym ::= 𝑇1 ⇒ 𝐴1 | . . . | 𝑇𝑛 ⇒ 𝐴𝑛, where each 𝐴𝑖 is the attribute that is
synthesized for sym in the given case, usually from attribute variables bound in 𝑇𝑖.
• Some productions are augmented by side conditions in parentheses, which restrict the applicability of the
production. They provide a shorthand for a combinatorial expansion of the production into many separate cases.
• A distinction is made between lexical and syntactic productions. For the latter, arbitrary white space is
allowed in any place where the grammar contains spaces. The productions defining lexical syntax and the
syntax of values are considered lexical, all others are syntactic.
Note: For example, the textual grammar for value types is given as follows:
valtype ::= ‘i32’ ⇒ i32
| ‘i64’ ⇒ i64
| ‘f32’ ⇒ f32
| ‘f64’ ⇒ f64
The textual grammar for limits is defined as follows:
limits ::= 𝑛:u32 ⇒ {min 𝑛, max 𝜖}
| 𝑛:u32 𝑚:u32 ⇒ {min 𝑛, max 𝑚}
The variables 𝑛 and 𝑚 name the attributes of the respective u32 nonterminals, which in this case are the actual
unsigned integers those parse into. The attribute of the complete production then is the abstract syntax for the
limit, expressed in terms of the former values.

6.1.2 Abbreviations
In addition to the core grammar, which corresponds directly to the abstract syntax, the textual syntax also defines
a number of abbreviations that can be used for convenience and readability.
Abbreviations are defined by rewrite rules specifying their expansion into the core syntax:
abbreviation syntax ≡ expanded syntax
These expansions are assumed to be applied, recursively and in order of appearance, before applying the core
grammar rules to construct the abstract syntax.

6.1.3 Contexts

The text format allows to use symbolic identifiers in place of indices. To resolve these identifiers into concrete
indices, some grammar production are indexed by an identifier context 𝐼 as a synthesized attribute that records the
declared identifiers in each index space. In addition, the context records the types defined in the module, so that
parameter indices can be computed for functions.
It is convenient to define identifier contexts as records 𝐼 with abstract syntax as follows:
𝐼 ::= { types (id?)*,funcs (id?)*,tables (id?)*,mems (id?)*,globals (id?)*,locals (id?)*,labels (id?)*,typedefs functype* }

For each index space, such a context contains the list of identifiers assigned to the defined indices. Unnamed
indices are associated with empty (𝜖) entries in these lists.
An identifier context is well-formed if no index space contains duplicate identifiers.
Conventions
To avoid unnecessary clutter, empty components are omitted when writing out identifier contexts. For example,
the record {} is shorthand for an identifier context whose components are all empty.

6.1.4 Vectors

Vectors are written as plain sequences, but with a restriction on the length of these sequence.

vec(A) ::= (𝑥:A) 𝑛 ⇒ 𝑥𝑛 (if 𝑛 < 2 32)

6.2 Lexical Format

6.2.1 Characters

The text format assigns meaning to source text, which consists of a sequence of characters. Characters are assumed
to be represented as valid Unicode38 (Section 2.4) code points.
source ::= char*
char ::= U+00 | . . . | U+D7FF | U+E000 | . . . | U+10FFFF

Note: While source text may contain any Unicode character in comments or string literals, the rest of the grammar
is formed exclusively from the characters supported by the 7-bit ASCII39 subset of Unicode.

6.2.2 Tokens

The character stream in the source text is divided, from left to right, into a sequence of tokens, as defined by the
following grammar.

token ::= keyword | u𝑁 | s𝑁 | f𝑁 | string | id | ‘(’ | ‘)’ | reserved
keyword ::= (‘a’ | . . . | ‘z’) idchar*
(if occurring as a literal terminal in the grammar)
reserved ::= idchar+

Tokens are formed from the input character stream according to the longest match rule. That is, the next token
always consists of the longest possible sequence of characters that is recognized by the above lexical grammar.
Tokens can be separated by white space, but except for strings, they cannot themselves contain whitespace.
The set of keyword tokens is defined implicitly, by all occurrences of a terminal symbol in literal form ‘keyword’
in a syntactic production of this chapter.
Any token that does not fall into any of the other categories is considered reserved, and cannot occur in source
text.

Note: The effect of defining the set of reserved tokens is that all tokens must be separated by either parentheses
or white space. For example, ‘0$x’ is a single reserved token. Consequently, it is not recognized as two separate

38 http://www.unicode.org/versions/latest/
39 http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d

tokens ‘0’ and ‘$x’, but instead disallowed. This property of tokenization is not affected by the fact that the
definition of reserved tokens overlaps with other token classes.

6.2.3 White Space

White space is any sequence of literal space characters, formatting characters, or comments. The allowed formatting
characters correspond to a subset of the ASCII40 format effectors, namely, horizontal tabulation (U+09), line

feed (U+0A), and carriage return (U+0D).
space ::= (‘ ’ | format | comment)*
format ::= U+09 | U+0A | U+0D

The only relevance of white space is to separate tokens, it is ignored otherwise.

6.2.4 Comments

A comment can either be a line comment, started with a double semicolon ‘;;’ and extending to the end of the line,
or a block comment, enclosed in delimiters ‘(;’ . . . ‘;)’. Block comments can be nested.

comment ::= linecomment | blockcomment
linecomment ::= ‘;;’ linechar*(U+0A | eof)
linechar ::= 𝑐:char (if 𝑐 ̸= U+0A)
blockcomment ::= ‘(;’ blockchar*‘;)’
blockchar ::= 𝑐:char (if 𝑐 ̸= ‘;’ ∧ 𝑐 ̸= ‘(’)
| ‘;’ (if the next character is not ‘)’)
| ‘(’ (if the next character is not ‘;’)
| blockcomment

Here, the pseudo token eof indicates the end of the input. The look-ahead restrictions on the productions for
blockchar disambiguate the grammar such that only well-bracketed uses of block comment delimiters are allowed.
Note: Any formatting and control characters are allowed inside comments.

6.3 Values

The grammar productions in this section define lexical syntax, hence no white space is allowed.

6.3.1 Integers

All integers can be written in either decimal or hexadecimal notation. In both cases, digits can optionally be
separated by underscores.

sign ::= 𝜖 ⇒ + | ‘+’ ⇒ + | ‘−’ ⇒ −
digit ::= ‘0’ ⇒ 0 | . . . | ‘9’ ⇒ 9
hexdigit ::= 𝑑:digit ⇒ 𝑑 | ‘A’ ⇒ 10 | . . . | ‘F’ ⇒ 15 | ‘a’ ⇒ 10 | . . . | ‘f’ ⇒ 15
num ::= 𝑑:digit ⇒ 𝑑 | 𝑛:num ‘_’?
𝑑:digit ⇒ 10 · 𝑛 + 𝑑
hexnum ::= ℎ:hexdigit ⇒ ℎ | 𝑛:hexnum ‘_’? ℎ:hexdigit ⇒ 16 · 𝑛 + ℎ

40 http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d

The allowed syntax for integer literals depends on size and signedness. Moreover, their value must lie within the
range of the respective type.
u𝑁 ::= 𝑛:num ⇒ 𝑛 (if 𝑛 < 2 𝑁 ) | ‘0x’ 𝑛:hexnum ⇒ 𝑛 (if 𝑛 < 2 𝑁 )
s𝑁 ::= ±:sign 𝑛:num ⇒ ±𝑛 (if −2 𝑁−1 ≤ ±𝑛 < 2 𝑁−1)
| ±:sign ‘0x’ 𝑛:hexnum ⇒ ±𝑛 (if −2 𝑁−1 ≤ ±𝑛 < 2 𝑁−1)

Uninterpreted integers can be written as either signed or unsigned, and are normalized to unsigned in the abstract
syntax.
i𝑁 ::= 𝑛:u𝑁 ⇒ 𝑛 | 𝑖:s𝑁 ⇒ 𝑛 (if 𝑖 = signed(𝑛))

6.3.2 Floating-Point

Floating-point values can be represented in either decimal or hexadecimal notation.

frac ::= 𝜖 ⇒ 0
| 𝑑:digit 𝑞:frac ⇒ (𝑑 + 𝑞)/10
| 𝑑:digit ‘_’ 𝑝:digit 𝑞:frac ⇒ (𝑑 + (𝑝 + 𝑞)/10)/10

hexfrac ::= 𝜖 ⇒ 0
| ℎ:hexdigit 𝑞:hexfrac ⇒ (ℎ + 𝑞)/16
| ℎ:hexdigit ‘_’ 𝑝:hexdigit 𝑞:hexfrac ⇒ (ℎ + (𝑝 + 𝑞)/16)/16

float ::= 𝑝:num ‘.’ 𝑞:frac ⇒ 𝑝 + 𝑞
| 𝑝:num (‘E’ | ‘e’) ±:sign 𝑒:num ⇒ 𝑝 · 10±𝑒
| 𝑝:num ‘.’ 𝑞:frac (‘E’ | ‘e’) ±:sign 𝑒:num ⇒ (𝑝 + 𝑞) · 10±𝑒

hexfloat ::= ‘0x’ 𝑝:hexnum ‘.’ 𝑞:hexfrac ⇒ 𝑝 + 𝑞
| ‘0x’ 𝑝:hexnum (‘P’ | ‘p’) ±:sign 𝑒:num ⇒ 𝑝 · 2±𝑒
| ‘0x’ 𝑝:hexnum ‘.’ 𝑞:hexfrac (‘P’ | ‘p’) ±:sign 𝑒:num ⇒ (𝑝 + 𝑞) · 2±𝑒

The value of a literal must not lie outside the representable range of the corresponding IEEE 754-200841 type (that
is, a numeric value must not overflow to ±infinity), but it may be rounded to the nearest representable value.

Note: Rounding can be prevented by using hexadecimal notation with no more significant bits than supported by
the required type.

Floating-point values may also be written as constants for infinity or canonical NaN (not a number). Furthermore,
arbitrary NaN values may be expressed by providing an explicit payload value.

f𝑁 ::= ±:sign 𝑧:f𝑁mag ⇒ ±𝑧
f𝑁mag ::= 𝑧:float ⇒ float𝑁 (𝑧) (if float𝑁 (𝑧) ̸= ±∞)
| 𝑧:hexfloat ⇒ float𝑁 (𝑧) (if float𝑁 (𝑧) ̸= ±∞)
| ‘inf’ ⇒ ∞
| ‘nan’ ⇒ nan(2signif(𝑁)−1)
| ‘nan:0x’ 𝑛:hexnum ⇒ nan(𝑛) (if 1 ≤ 𝑛 < 2 signif(𝑁))

6.3.3 Strings
Strings denote sequences of bytes that can represent both textual and binary data. They are enclosed in quotation
marks and may contain any character other than ASCII42 control characters, quotation marks (‘”’), or backslash

41 http://ieeexplore.ieee.org/document/4610935/
42 http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d

(‘∖’), except when expressed with an escape sequence.
string ::= ‘”’ (𝑏*:stringelem)* ‘”’ ⇒ concat((𝑏*)*) (if |concat((𝑏*)*)| < 2 32) stringelem ::= 𝑐:stringchar ⇒ utf8(𝑐)
| ‘∖’ 𝑛:hexdigit 𝑚:hexdigit ⇒ 16 · 𝑛 + 𝑚

Each character in a string literal represents the byte sequence corresponding to its UTF-8 Unicode43 (Section 2.5)
encoding, except for hexadecimal escape sequences ‘∖ℎℎ’, which represent raw bytes of the respective value.

stringchar ::= 𝑐:char ⇒ 𝑐 (if 𝑐 ≥ U+20 ∧ 𝑐 ̸= U+7F ∧ 𝑐 ̸= ‘”’𝑐 ̸= ‘∖’)
| ‘∖t’ ⇒ U+09
| ‘∖n’ ⇒ U+0A
| ‘∖r’ ⇒ U+0D
| ‘∖”’ ⇒ U+22
| ‘∖′’ ⇒ U+27
| ‘∖∖’ ⇒ U+5C
| ‘∖u{’ 𝑛:hexnum ‘}’ ⇒ U+(n) (if 𝑛 < 0xD800 ∨ 0xE000 ≤ 𝑛 < 0x110000)

6.3.4 Names

Names are strings denoting a literal character sequence. A name string must form a valid UTF-8 encoding as
defined by Unicode44 (Section 2.5) that is interpreted as a string of Unicode code points.

name ::= 𝑏*
:string ⇒ 𝑐*
(if 𝑏* = utf8(𝑐*))
Note: Presuming the source text is itself encoded correctly, strings that do not contain any uses of hexadecimal
byte escapes are always valid names.

6.3.5 Identifiers

Indices can be given in both numeric and symbolic form. Symbolic identifiers that stand in lieu of indices start
with ‘$’, followed by any sequence of printable ASCII45 characters that does not contain a space, quotation mark,
comma, semicolon, or bracket.

id ::= ‘$’ idchar+
idchar ::= ‘0’ | . . . | ‘9’
| ‘A’ | . . . | ‘Z’
| ‘a’ | . . . | ‘z’
| ‘!’ | ‘#’ | ‘$’ | ‘%’ | ‘&’ | ‘′’ | ‘*’ | ‘+’ | ‘−’ | ‘.’ | ‘/’
| ‘:’ | ‘<’ | ‘=’ | ‘>’ | ‘?’ | ‘@’ | ‘∖’ | ‘^’ | ‘_’ | ‘`’ | ‘|’ | ‘~’

Conventions
The expansion rules of some abbreviations require insertion of a fresh identifier. That may be any syntactically
valid identifier that does not already occur in the given source text.

43 http://www.unicode.org/versions/latest/
44 http://www.unicode.org/versions/latest/
45 http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d

6.4 Types

6.4.1 Value Types

valtype ::= ‘i32’ ⇒ i32
| ‘i64’ ⇒ i64
| ‘f32’ ⇒ f32
| ‘f64’ ⇒ f64

6.4.2 Result Types

resulttype ::= (𝑡:result)? ⇒ [𝑡?]
Note: In future versions of WebAssembly, this scheme may be extended to support multiple results or more
general result types.

6.4.3 Function Types

functype ::= ‘(’ ‘func’ 𝑡*1: vec(param) 𝑡*2: vec(result) ‘)’ ⇒ [𝑡*1] → [𝑡*2]
param ::= ‘(’ ‘param’ id? 𝑡:valtype ‘)’ ⇒ 𝑡
result ::= ‘(’ ‘result’ 𝑡:valtype ‘)’ ⇒ 𝑡

Abbreviations
Multiple anonymous parameters or results may be combined into a single declaration:
‘(’ ‘param’ valtype*‘)’ ≡ (‘(’ ‘param’ valtype ‘)’)*
‘(’ ‘result’ valtype*‘)’ ≡ (‘(’ ‘result’ valtype ‘)’)*

6.4.4 Limits

limits ::= 𝑛:u32 ⇒ {min 𝑛, max 𝜖}
| 𝑛:u32 𝑚:u32 ⇒ {min 𝑛, max 𝑚}

6.4.5 Memory Types
memtype ::= lim:limits ⇒ lim

6.4.6 Table Types

tabletype ::= lim:limits et:elemtype ⇒ lim et
elemtype ::= ‘anyfunc’ ⇒ anyfunc
Note: Additional element types may be introduced in future versions of WebAssembly.

6.4.7 Global Types

globaltype ::= 𝑡:valtype ⇒ const 𝑡| ‘(’ ‘mut’ 𝑡:valtype ‘)’ ⇒ var 𝑡

6.5 Instructions

Instructions are syntactically distinguished into plain and structured instructions.

instr𝐼 ::= in:plaininstr𝐼 ⇒ in
| in:blockinstr𝐼 ⇒ in

In addition, as a syntactic abbreviation, instructions can be written as S-expressions in folded form, to group them
visually.

6.5.1 Labels

Structured control instructions can be annotated with a symbolic label identifier. They are the only symbolic
identifiers that can be bound locally in an instruction sequence. The following grammar handles the corresponding
update to the identifier context by composing the context with an additional label entry.

label𝐼 ::= 𝑣:id ⇒ {labels 𝑣} ⊕ 𝐼 (if 𝑣 /∈ 𝐼.labels)
| 𝜖 ⇒ {labels (𝜖)} ⊕ 𝐼

Note: The new label entry is inserted at the beginning of the label list in the identifier context. This effectively
shifts all existing labels up by one, mirroring the fact that control instructions are indexed relatively not absolutely.

6.5.2 Control Instructions

Structured control instructions can bind an optional symbolic label identifier. The same label identifier may optionally
be repeated after the corresponding end and else pseudo instructions, to indicate the matching delimiters.

blockinstr𝐼 ::= ‘block’ 𝐼′:label𝐼 rt:resulttype (in:instr𝐼′ )* ‘end’ id? ⇒ block rt in*end (if id? = 𝜖 ∨ id? = label)
| ‘loop’ 𝐼′:label𝐼 rt:resulttype (in:instr𝐼′ )*‘end’ id?⇒ loop rt in* end (if id? = 𝜖 ∨ id? = label)
| ‘if’ 𝐼′:label𝐼 rt:resulttype (in1:instr𝐼′ )* ‘else’ id? 1 (in2:instr𝐼′ )* ‘end’ id?2 ⇒ if rt in* 1 else in* 2 end (if id? 1 = 𝜖 ∨ id? 1 = label, id? 2 = 𝜖 ∨ id? 2 = label)

All other control instruction are represented verbatim.
plaininstr𝐼 ::= ‘unreachable’ ⇒ unreachable
| ‘nop’ ⇒ nop
| ‘br’ 𝑙:labelidx𝐼 ⇒ br 𝑙
| ‘br_if’ 𝑙:labelidx𝐼 ⇒ br_if 𝑙
| ‘br_table’ 𝑙* :vec(labelidx𝐼 ) 𝑙𝑁 :labelidx𝐼 ⇒ br_table 𝑙*𝑙𝑁
| ‘return’ ⇒ return
| ‘call’ 𝑥:funcidx𝐼 ⇒ call 𝑥
| ‘call_indirect’ 𝑥, 𝐼′:typeuse𝐼 ⇒ call_indirect 𝑥 (if 𝐼′ = {})
Note: The side condition stating that the identifier context 𝐼′ must be empty in the rule for call_indirect
enforces that no identifier can be bound in any param declaration appearing in the type annotation.

Abbreviations
The ‘else’ keyword of an ‘if’ instruction can be omitted if the following instruction sequence is empty.

‘if’ label resulttype instr* ‘end’ ≡ ‘if’ label resulttype instr* ‘else’ ‘end’

6.5.3 Parametric Instructions

plaininstr𝐼 ::= . . .
| ‘drop’ ⇒ drop
| ‘select’ ⇒ select

6.5.4 Variable Instructions

plaininstr𝐼 ::= . . .
| ‘get_local’ 𝑥:localidx𝐼 ⇒ get_local 𝑥
| ‘set_local’ 𝑥:localidx𝐼 ⇒ set_local 𝑥
| ‘tee_local’ 𝑥:localidx𝐼 ⇒ tee_local 𝑥
| ‘get_global’ 𝑥:globalidx𝐼 ⇒ get_global 𝑥
| ‘set_global’ 𝑥:globalidx𝐼 ⇒ set_global 𝑥

6.5.5 Memory Instructions

The offset and alignment immediates to memory instructions are optional. The offset defaults to 0, the alignment
to the storage size of the respective memory access, which is its natural alignment. Lexically, an offset or align
phrase is considered a single keyword token, so no white space is allowed around the ‘=’.

memarg𝑁 ::= 𝑜:offset 𝑎:align𝑁 ⇒ {align 𝑛, offset 𝑜} (if 𝑎 = 2𝑛)
offset ::= ‘offset=’𝑜:u32 ⇒ 𝑜
| 𝜖 ⇒ 0 align𝑁 ::= ‘align=’𝑎:u32 ⇒ 𝑎
| 𝜖 ⇒ 𝑁 plaininstr𝐼 ::= . . .
| ‘i32.load’ 𝑚:memarg4 ⇒ i32.load 𝑚
| ‘i64.load’ 𝑚:memarg8 ⇒ i64.load 𝑚
| ‘f32.load’ 𝑚:memarg4 ⇒ f32.load 𝑚
| ‘f64.load’ 𝑚:memarg8 ⇒ f64.load 𝑚
| ‘i32.load8_s’ 𝑚:memarg1 ⇒ i32.load8_s 𝑚
| ‘i32.load8_u’ 𝑚:memarg1 ⇒ i32.load8_u 𝑚
| ‘i32.load16_s’ 𝑚:memarg2 ⇒ i32.load16_s 𝑚
| ‘i32.load16_u’ 𝑚:memarg2 ⇒ i32.load16_u 𝑚
| ‘i64.load8_s’ 𝑚:memarg1 ⇒ i64.load8_s 𝑚
| ‘i64.load8_u’ 𝑚:memarg1 ⇒ i64.load8_u 𝑚
| ‘i64.load16_s’ 𝑚:memarg2 ⇒ i64.load16_s 𝑚
| ‘i64.load16_u’ 𝑚:memarg2 ⇒ i64.load16_u 𝑚
| ‘i64.load32_s’ 𝑚:memarg4 ⇒ i64.load32_s 𝑚
| ‘i64.load32_u’ 𝑚:memarg4 ⇒ i64.load32_u 𝑚
| ‘i32.store’ 𝑚:memarg4 ⇒ i32.store 𝑚
| ‘i64.store’ 𝑚:memarg8 ⇒ i64.store 𝑚
| ‘f32.store’ 𝑚:memarg4 ⇒ f32.store 𝑚
| ‘f64.store’ 𝑚:memarg8 ⇒ f64.store 𝑚
| ‘i32.store8’ 𝑚:memarg1 ⇒ i32.store8 𝑚
| ‘i32.store16’ 𝑚:memarg2 ⇒ i32.store16 𝑚
| ‘i64.store8’ 𝑚:memarg1 ⇒ i64.store8 𝑚
| ‘i64.store16’ 𝑚:memarg2 ⇒ i64.store16 𝑚
| ‘i64.store32’ 𝑚:memarg4 ⇒ i64.store32 𝑚
| ‘current_memory’ ⇒ current_memory
| ‘grow_memory’ ⇒ grow_memory

6.5.6 Numeric Instructions

plaininstr𝐼 ::= . . .
| ‘i32.const’ 𝑛:i32 ⇒ i32.const 𝑛
| ‘i64.const’ 𝑛:i64 ⇒ i64.const 𝑛
| ‘f32.const’ 𝑧:f32 ⇒ f32.const 𝑧
| ‘f64.const’ 𝑧:f64 ⇒ f64.const 𝑧
| ‘i32.clz’ ⇒ i32.clz
| ‘i32.ctz’ ⇒ i32.ctz
| ‘i32.popcnt’ ⇒ i32.popcnt
| ‘i32.add’ ⇒ i32.add
| ‘i32.sub’ ⇒ i32.sub
| ‘i32.mul’ ⇒ i32.mul
| ‘i32.div_s’ ⇒ i32.div_s
| ‘i32.div_u’ ⇒ i32.div_u
| ‘i32.rem_s’ ⇒ i32.rem_s
| ‘i32.rem_u’ ⇒ i32.rem_u
| ‘i32.and’ ⇒ i32.and
| ‘i32.or’ ⇒ i32.or
| ‘i32.xor’ ⇒ i32.xor
| ‘i32.shl’ ⇒ i32.shl
| ‘i32.shr_s’ ⇒ i32.shr_s
| ‘i32.shr_u’ ⇒ i32.shr_u
| ‘i32.rotl’ ⇒ i32.rotl
| ‘i32.rotr’ ⇒ i32.rotr
| ‘i64.clz’ ⇒ i64.clz
| ‘i64.ctz’ ⇒ i64.ctz
| ‘i64.popcnt’ ⇒ i64.popcnt
| ‘i64.add’ ⇒ i64.add
| ‘i64.sub’ ⇒ i64.sub
| ‘i64.mul’ ⇒ i64.mul
| ‘i64.div_s’ ⇒ i64.div_s
| ‘i64.div_u’ ⇒ i64.div_u
| ‘i64.rem_s’ ⇒ i64.rem_s
| ‘i64.rem_u’ ⇒ i64.rem_u
| ‘i64.and’ ⇒ i64.and
| ‘i64.or’ ⇒ i64.or
| ‘i64.xor’ ⇒ i64.xor
| ‘i64.shl’ ⇒ i64.shl
| ‘i64.shr_s’ ⇒ i64.shr_s
| ‘i64.shr_u’ ⇒ i64.shr_u
| ‘i64.rotl’ ⇒ i64.rotl
| ‘i64.rotr’ ⇒ i64.rotr
| ‘f32.abs’ ⇒ f32.abs
| ‘f32.neg’ ⇒ f32.neg
| ‘f32.ceil’ ⇒ f32.ceil
| ‘f32.floor’ ⇒ f32.floor
| ‘f32.trunc’ ⇒ f32.trunc
| ‘f32.nearest’ ⇒ f32.nearest
| ‘f32.sqrt’ ⇒ f32.sqrt
| ‘f32.add’ ⇒ f32.add
| ‘f32.sub’ ⇒ f32.sub
| ‘f32.mul’ ⇒ f32.mul
| ‘f32.div’ ⇒ f32.div
| ‘f32.min’ ⇒ f32.min
| ‘f32.max’ ⇒ f32.max
| ‘f32.copysign’ ⇒ f32.copysign
| ‘f64.abs’ ⇒ f64.abs
| ‘f64.neg’ ⇒ f64.neg
| ‘f64.ceil’ ⇒ f64.ceil
| ‘f64.floor’ ⇒ f64.floor
| ‘f64.trunc’ ⇒ f64.trunc
| ‘f64.nearest’ ⇒ f64.nearest
| ‘f64.sqrt’ ⇒ f64.sqrt
| ‘f64.add’ ⇒ f64.add
| ‘f64.sub’ ⇒ f64.sub
| ‘f64.mul’ ⇒ f64.mul
| ‘f64.div’ ⇒ f64.div
| ‘f64.min’ ⇒ f64.min
| ‘f64.max’ ⇒ f64.max
| ‘f64.copysign’ ⇒ f64.copysign
| ‘i32.eqz’ ⇒ i32.eqz
| ‘i32.eq’ ⇒ i32.eq
| ‘i32.ne’ ⇒ i32.ne
| ‘i32.lt_s’ ⇒ i32.lt_s
| ‘i32.lt_u’ ⇒ i32.lt_u
| ‘i32.gt_s’ ⇒ i32.gt_s
| ‘i32.gt_u’ ⇒ i32.gt_u
| ‘i32.le_s’ ⇒ i32.le_s
| ‘i32.le_u’ ⇒ i32.le_u
| ‘i32.ge_s’ ⇒ i32.ge_s
| ‘i32.ge_u’ ⇒ i32.ge_u
| ‘i64.eqz’ ⇒ i64.eqz
| ‘i64.eq’ ⇒ i64.eq
| ‘i64.ne’ ⇒ i64.ne
| ‘i64.lt_s’ ⇒ i64.lt_s
| ‘i64.lt_u’ ⇒ i64.lt_u
| ‘i64.gt_s’ ⇒ i64.gt_s
| ‘i64.gt_u’ ⇒ i64.gt_u
| ‘i64.le_s’ ⇒ i64.le_s
| ‘i64.le_u’ ⇒ i64.le_u
| ‘i64.ge_s’ ⇒ i64.ge_s
| ‘i64.ge_u’ ⇒ i64.ge_u
| ‘f32.eq’ ⇒ f32.eq
| ‘f32.ne’ ⇒ f32.ne
| ‘f32.lt’ ⇒ f32.lt
| ‘f32.gt’ ⇒ f32.gt
| ‘f32.le’ ⇒ f32.le
| ‘f32.ge’ ⇒ f32.ge
| ‘f64.eq’ ⇒ f64.eq
| ‘f64.ne’ ⇒ f64.ne
| ‘f64.lt’ ⇒ f64.lt
| ‘f64.gt’ ⇒ f64.gt
| ‘f64.le’ ⇒ f64.le
| ‘f64.ge’ ⇒ f64.ge
| ‘i32.wrap/i64’ ⇒ i32.wrap/i64
| ‘i32.trunc_s/f32’ ⇒ i32.trunc_s/f32
| ‘i32.trunc_u/f32’ ⇒ i32.trunc_u/f32
| ‘i32.trunc_s/f64’ ⇒ i32.trunc_s/f64
| ‘i32.trunc_u/f64’ ⇒ i32.trunc_u/f64
| ‘i64.extend_s/i32’ ⇒ i64.extend_s/i32
| ‘i64.extend_u/i32’ ⇒ i64.extend_u/i32
| ‘i64.trunc_s/f32’ ⇒ i64.trunc_s/f32
| ‘i64.trunc_u/f32’ ⇒ i64.trunc_u/f32
| ‘i64.trunc_s/f64’ ⇒ i64.trunc_s/f64
| ‘i64.trunc_u/f64’ ⇒ i64.trunc_u/f64
| ‘f32.convert_s/i32’ ⇒ f32.convert_s/i32
| ‘f32.convert_u/i32’ ⇒ f32.convert_u/i32
| ‘f32.convert_s/i64’ ⇒ f32.convert_s/i64
| ‘f32.convert_u/i64’ ⇒ f32.convert_u/i64
| ‘f32.demote/f64’ ⇒ f32.demote/f64
| ‘f64.convert_s/i32’ ⇒ f64.convert_s/i32
| ‘f64.convert_u/i32’ ⇒ f64.convert_u/i32
| ‘f64.convert_s/i64’ ⇒ f64.convert_s/i64
| ‘f64.convert_u/i64’ ⇒ f64.convert_u/i64
| ‘f64.promote/f32’ ⇒ f64.promote/f32
| ‘i32.reinterpret/f32’ ⇒ i32.reinterpret/f32
| ‘i64.reinterpret/f64’ ⇒ i64.reinterpret/f64
| ‘f32.reinterpret/i32’ ⇒ f32.reinterpret/i32
| ‘f64.reinterpret/i64’ ⇒ f64.reinterpret/i64

6.5.7 Folded Instructions

Instructions can be written as S-expressions by grouping them into folded form. In that notation, an instruction
is wrapped in parentheses and optionally includes nested folded instructions to indicate its operands.
In the case of block instructions, the folded form omits the ‘end’ delimiter. For if instructions, both branches
have to wrapped into nested S-expressions, headed by the keywords ‘then’ and ‘else’.
The set of all phrases defined by the following abbreviations recursively forms the auxiliary syntactic class
foldedinstr. Such a folded instruction can appear anywhere a regular instruction can.

‘(’ plaininstr foldedinstr*‘)’ ≡ foldedinstr* plaininstr
‘(’ ‘block’ label resulttype instr*‘)’ ≡ ‘block’ label resulttype instr* ‘end’
‘(’ ‘loop’ label resulttype instr*‘)’ ≡ ‘loop’ label resulttype instr* ‘end’
‘(’ ‘if’ label resulttype foldedinstr* ‘(’ ‘then’ instr* 1 ‘)’ ‘(’ ‘else’ instr* 2‘)’ ? ‘)’ ≡ foldedinstr* ‘if’ label resulttype instr* 1 ‘else’ (instr*2 )? ‘end’

Note: Folded instructions are solely syntactic sugar, no additional syntactic or type-based checking is implied.

6.5.8 Expressions

Expressions are written as instruction sequences. No explicit ‘end’ keyword is included, since they only occur in
bracketed positions.
expr ::= (in:instr) * ⇒ in* end

6.6 Modules

6.6.1 Indices

Indices can be given either in raw numeric form or as symbolic identifiers when bound by a respective construct.
Such identifiers are looked up in the suitable space of the identifier context 𝐼.

typeidx𝐼 ::= 𝑥:u32 ⇒ 𝑥
| 𝑣:id ⇒ 𝑥 (if 𝐼.types[𝑥] = 𝑣)

funcidx𝐼 ::= 𝑥:u32 ⇒ 𝑥
| 𝑣:id ⇒ 𝑥 (if 𝐼.funcs[𝑥] = 𝑣)

tableidx𝐼 ::= 𝑥:u32 ⇒ 𝑥
| 𝑣:id ⇒ 𝑥 (if 𝐼.tables[𝑥] = 𝑣)

memidx𝐼 ::= 𝑥:u32 ⇒ 𝑥
| 𝑣:id ⇒ 𝑥 (if 𝐼.mems[𝑥] = 𝑣)

globalidx𝐼 ::= 𝑥:u32 ⇒ 𝑥
| 𝑣:id ⇒ 𝑥 (if 𝐼.globals[𝑥] = 𝑣)

localidx𝐼 ::= 𝑥:u32 ⇒ 𝑥
| 𝑣:id ⇒ 𝑥 (if 𝐼.locals[𝑥] = 𝑣)

labelidx𝐼 ::= 𝑙:u32 ⇒ 𝑙
| 𝑣:id ⇒ 𝑙 (if 𝐼.labels[𝑙] = 𝑣)

6.6.2 Types
Type definitions can bind a symbolic type identifier.
type ::= ‘(’ ‘type’ id? ft:functype ‘)’ ⇒ ft

6.6.3 Type Uses

A type use is a reference to a type definition. It may optionally be augmented by explicit inlined parameter and
result declarations. That allows binding symbolic identifiers to name the local indices of parameters. If inline
declarations are given, then their types must match the referenced function type.

typeuse𝐼 ::= ‘(’ ‘type’ 𝑥:typeidx𝐼 ‘)’ ⇒ 𝑥, 𝐼′
(if 𝐼.typedefs[𝑥] = [𝑡𝑛 1] → [𝑡*2] ∧ 𝐼′ = {locals (𝜖)𝑛}) | ‘(’ ‘type’ 𝑥:typeidx𝐼 ‘)’ (𝑡1:param)* (𝑡2:result)* ⇒ 𝑥, 𝐼′ (if 𝐼.typedefs[𝑥] = [𝑡*1] → [𝑡*2] ∧ 𝐼′ = {locals id(param)}* well-formed)

The synthesized attribute of a typeuse is a pair consisting of both the used type index and the updated identifier
context including possible parameter identifiers. The following auxiliary function extracts optional identifiers
from parameters: id(‘(’ ‘param’ id?. . . ‘)’) = id?

Note: Both productions overlap for the case that the function type is [] → []. However, in that case, they also
produce the same results, so that the choice is immaterial.
The well-formedness condition on 𝐼′ ensures that the parameters do not contain duplicate identifier.

Abbreviations
A typeuse may also be replaced entirely by inline parameter and result declarations. In that case, a type index is
automatically inserted:
(𝑡1:param)* (𝑡2:result)* ≡ ‘(’ ‘type’ 𝑥 ‘)’ param* result*
where 𝑥 is the smallest existing type index whose definition in the current module is the function type [𝑡*1] → [𝑡*2].
If no such index exists, then a new type definition of the form ‘(’ ‘type’ ‘(’ ‘func’ param* result ‘)’ ‘)’
is inserted at the end of the module.

Abbreviations are expanded in the order they appear, such that previously inserted type definitions are reused by
consecutive expansions.

6.6.4 Imports

The descriptors in imports can bind a symbolic function, table, memory, or global identifier.

import𝐼 ::= ‘(’ ‘import’ mod:name nm:name 𝑑:importdesc𝐼 ‘)’ ⇒ {module mod, name nm, desc 𝑑}
importdesc𝐼 ::= ‘(’ ‘func’ id? 𝑥, 𝐼′ :typeuse𝐼 ‘)’ ⇒ func 𝑥
| ‘(’ ‘table’ id? tt:tabletype ‘)’ ⇒ table tt
| ‘(’ ‘memory’ id? mt:memtype ‘)’ ⇒ mem mt
| ‘(’ ‘global’ id? gt:globaltype ‘)’ ⇒ global gt

Abbreviations
As an abbreviation, imports may also be specified inline with function, table, memory, or global definitions; see
the respective sections.

6.6.5 Functions
Function definitions can bind a symbolic function identifier, and local identifiers for its parameters and locals.
func𝐼 ::= ‘(’ ‘func’ id? 𝑥, 𝐼′ :typeuse𝐼 (𝑡:local)* (in:instr𝐼′′ )*‘)’ ⇒ {type 𝑥, locals 𝑡*, body in* end}
(if 𝐼′′ = 𝐼′ ⊕ {locals id(local)*} well-formed)
local ::= ‘(’ ‘local’ id? 𝑡:valtype ‘)’ ⇒ 𝑡
The definition of the local identifier context 𝐼′′ uses the following auxiliary function to extract optional
identifiers from locals:
id(‘(’ ‘local’ id?. . . ‘)’) = id?
Note: The well-formedness condition on 𝐼′′ ensures that parameters and locals do not contain duplicate identifiers.

Abbreviations
Multiple anonymous locals may be combined into a single declaration:
‘(’ ‘local’ valtype*‘)’ ≡ (‘(’ ‘local’ valtype ‘)’)*

Moreover, functions can be defined as imports or exports inline:
‘(’ ‘func’ id?
‘(’ ‘import’ name1 name2 ‘)’ typeuse ‘)’ ≡
‘(’ ‘import’ name1 name2 ‘(’ ‘func’ id? typeuse ‘)’ ‘)’
‘(’ ‘func’ id?
‘(’ ‘export’ name ‘)’ . . . ‘)’ ≡
‘(’ ‘export’ name ‘(’ ‘func’ id′
‘)’ ‘)’ ‘(’ ‘func’ id′. . . ‘)’
(if id′ = id? ̸= 𝜖 ∨ id′ fresh)
The latter abbreviation can be applied repeatedly, with “. . .” containing another import or export.

6.6.6 Tables

Table definitions can bind a symbolic table identifier.
table𝐼 ::= ‘(’ ‘table’ id?tt:tabletype ‘)’ ⇒ {type tt}

Abbreviations
An element segment can be given inline with a table definition, in which case the limits of the table type are
inferred from the length of the given segment:
‘(’ ‘table’ id? elemtype ‘(’ ‘elem’ 𝑥𝑛:vec(funcidx) ‘)’ ‘)’ ≡
‘(’ ‘table’ id′ 𝑛 𝑛 elemtype ‘)’ ‘(’ ‘elem’ id′
‘(’ ‘i32.const’ ‘0’ ‘)’ vec(funcidx) ‘)’
(if id′ = id? ̸= 𝜖 ∨ id′ fresh)

Moreover, tables can be defined as imports or exports inline:
‘(’ ‘table’ id?
‘(’ ‘import’ name1 name2 ‘)’ tabletype ‘)’ ≡
‘(’ ‘import’ name1 name2 ‘(’ ‘table’ id? tabletype ‘)’ ‘)’
‘(’ ‘table’ id?
‘(’ ‘export’ name ‘)’ . . . ‘)’ ≡
‘(’ ‘export’ name ‘(’ ‘table’ id′
‘)’ ‘)’ ‘(’ ‘table’ id′. . . ‘)’
(if id′ = id? ̸= 𝜖 ∨ id′ fresh)
The latter abbreviation can be applied repeatedly, with “. . .” containing another import or export or an inline
elements segment.

6.6.7 Memories

Memory definitions can bind a symbolic memory identifier.
mem𝐼 ::= ‘(’ ‘memory’ id? mt:memtype ‘)’ ⇒ {type mt}

Abbreviations
A data segment can be given inline with a memory definition, in which case the limits of the memory type are
inferred from the length of the data, rounded up to page size:
‘(’ ‘memory’ id?
‘(’ ‘data’ 𝑏𝑛:datastring ‘)’ ‘)’ ≡
‘(’ ‘memory’ id′ 𝑚 𝑚 ‘)’ ‘(’ ‘data’ id′
‘(’ ‘i32.const’ ‘0’ ‘)’ datastring ‘)’
(if id′ = id? ̸= 𝜖 ∨ id′ fresh, 𝑚 = ceil(𝑛/64Ki))

Moreover, memories can be defined as imports or exports inline:
‘(’ ‘memory’ id?
‘(’ ‘import’ name1 name2 ‘)’ memtype ‘)’ ≡
‘(’ ‘import’ name1 name2 ‘(’ ‘memory’ id? memtype ‘)’ ‘)’
‘(’ ‘memory’ id?
‘(’ ‘export’ name ‘)’ . . . ‘)’ ≡
‘(’ ‘export’ name ‘(’ ‘memory’ id′
‘)’ ‘)’ ‘(’ ‘memory’ id′. . . ‘)’
(if id′ = id? ̸= 𝜖 ∨ id′ fresh)
The latter abbreviation can be applied repeatedly, with “. . .” containing another import or export or an
inline data segment.

6.6.8 Globals
Global definitions can bind a symbolic global identifier.
global𝐼 ::= ‘(’ ‘global’ id?
gt:globaltype 𝑒:expr𝐼 ‘)’ ⇒ {type gt, init 𝑒}
Abbreviations
Globals can be defined as imports or exports inline:
‘(’ ‘global’ id?
‘(’ ‘import’ name1 name2 ‘)’ globaltype ‘)’ ≡
‘(’ ‘import’ name1 name2 ‘(’ ‘global’ id? globaltype ‘)’ ‘)’
‘(’ ‘global’ id?
‘(’ ‘export’ name ‘)’ . . . ‘)’ ≡
‘(’ ‘export’ name ‘(’ ‘global’ id′
‘)’ ‘)’ ‘(’ ‘global’ id′. . . ‘)’
(if id′ = id? ̸= 𝜖 ∨ id′ fresh)
The latter abbreviation can be applied repeatedly, with “. . .” containing another import or export.

6.6.9 Exports

The syntax for exports mirrors their abstract syntax directly.
export𝐼 ::= ‘(’ ‘export’ nm:name 𝑑:exportdesc𝐼 ‘)’ ⇒ {name nm, desc 𝑑}
exportdesc𝐼 ::= ‘(’ ‘func’ 𝑥:funcidx𝐼 ‘)’ ⇒ func 𝑥
| ‘(’ ‘table’ 𝑥:tableidx𝐼 ‘)’ ⇒ table 𝑥
| ‘(’ ‘memory’ 𝑥:memidx𝐼 ‘)’ ⇒ mem 𝑥
| ‘(’ ‘global’ 𝑥:globalidx𝐼 ‘)’ ⇒ global 𝑥

Abbreviations
As an abbreviation, exports may also be specified inline with function, table, memory, or global definitions; see
the respective sections.

6.6.10 Start Function

A start function is defined in terms of its index.
start𝐼 ::= ‘(’ ‘start’ 𝑥:funcidx𝐼 ‘)’ ⇒ {func 𝑥}

Note: At most one start function may occur in a module, which is ensured by a suitable side condition on the
module grammar.

6.6.11 Element Segments
Element segments allow for an optional table index to identify the table to initialize. When omitted, 0 is assumed.
elem𝐼 ::= ‘(’ ‘elem’ (𝑥:tableidx𝐼 )? ‘(’ ‘offset’ 𝑒:expr𝐼 ‘)’ 𝑦* :vec(funcidx𝐼 ) ‘)’ ⇒ {table 𝑥′, offset 𝑒, init 𝑦*}
(if 𝑥′ = 𝑥? ̸= 𝜖 ∨ 𝑥′ = 0)

Note: In the current version of WebAssembly, the only valid table index is 0 or a symbolic table identifier
resolving to the same value.

Abbreviations
As an abbreviation, element segments may also be specified inline with table definitions; see the respective section.

6.6.12 Data Segments
Data segments allow for an optional memory index to identify the memory to initialize. When omitted, 0 is
assumed. The data is written as a string, which may be split up into a possibly empty sequence of individual string
literals.
data𝐼 ::= ‘(’ ‘data’ (𝑥:memidx𝐼 )? ‘(’ ‘offset’ 𝑒:expr𝐼 ‘)’ 𝑏*:datastring ‘)’ ⇒ {data 𝑥′, offset 𝑒, init 𝑏*}
(if 𝑥′ = 𝑥? ̸= 𝜖 ∨ 𝑥′ = 0) datastring ::= (𝑏*:string)* ⇒ concat((𝑏*)*)
Note: In the current version of WebAssembly, the only valid memory index is 0 or a symbolic memory identifier resolving to the same value.

Abbreviations
As an abbreviation, data segments may also be specified inline with memory definitions; see the respective section.

6.6.13 Modules
A module consists of a sequence of fields that can occur in any order. All definitions and their respective bound
identifiers scope over the entire module, including the text preceding them.
A module may optionally bind an identifier that names the module. The name serves a documentary role only.

Note: Tools may include the module name in the name section of the binary format.
module ::= ‘(’ ‘module’ id? (𝑚:modulefield𝐼 )*‘)’ ⇒ ⨁︀𝑚*
(if 𝐼 = ⨁︀idc(modulefield)* well-formed)
modulefield𝐼 ::=
  ty:type ⇒ {types ty}
| im:import𝐼 ⇒ {imports im}
| fn:func𝐼 ⇒ {funcs fn}
| ta:table𝐼 ⇒ {tables ta}
| me:mem𝐼 ⇒ {mems me}
| gl:global𝐼 ⇒ {globals gl}
| ex :export𝐼 ⇒ {exports ex}
| st:start𝐼 ⇒ {start st}
| el:elem𝐼 ⇒ {elem el}
| da:data𝐼 ⇒ {data da}

The following restrictions are imposed on the composition of modules: 𝑚1 ⊕ 𝑚2 is defined if and only if
• 𝑚1.start = 𝜖 ∨ 𝑚2.start = 𝜖
• 𝑚1.funcs = 𝑚1.tables = 𝑚1.mems = 𝑚1.globals = 𝜖 ∨ 𝑚2.imports = 𝜖

Note: The first condition ensures that there is at most one start function. The second condition enforces that all
imports must occur before any regular definition of a function, table, memory, or global, thereby maintaining the
ordering of the respective index spaces.
The well-formedness condition on 𝐼 in the grammar for module ensures that no namespace contains duplicate identifiers.
The definition of the initial identifier context 𝐼 uses the following auxiliary definition which maps each relevant
definition to a singular context with one (possibly empty) identifier:

idc(‘(’ ‘type’ id? ft:functype ‘)’) = {types (id?),typedefs ft}
idc(‘(’ ‘func’ id?. . . ‘)’) = {funcs (id?)}
idc(‘(’ ‘table’ id?. . . ‘)’) = {tables (id?)}
idc(‘(’ ‘memory’ id?. . . ‘)’) = {mems (id?)}
idc(‘(’ ‘global’ id?. . . ‘)’) = {globals (id?)}
idc(‘(’ ‘import’ . . . ‘(’ ‘func’ id?. . . ‘)’ ‘)’) = {funcs (id?)}
idc(‘(’ ‘import’ . . . ‘(’ ‘table’ id?. . . ‘)’ ‘)’) = {tables (id?)}
idc(‘(’ ‘import’ . . . ‘(’ ‘memory’ id?. . . ‘)’ ‘)’) = {mems (id?)}
idc(‘(’ ‘import’ . . . ‘(’ ‘global’ id?. . . ‘)’ ‘)’) = {globals (id?)}
idc(‘(’ . . . ‘)’) = {}

Abbreviations
In a source file, the toplevel (module . . .) surroundiing the module body may be omitted.
modulefield* ≡ ‘(’ ‘module’ modulefield* ‘)’